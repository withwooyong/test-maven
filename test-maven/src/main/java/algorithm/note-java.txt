################################################################################
################################################################################
1 OOP(Object Oriented Programming) 객체지향프로그래밍
코드의 재사용성이 높아 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다. 
코드의 관리가 용이하여 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다. 
메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다. 
1 캡슐화(encapsulation) & 은닉화(information hiding) 
2 상속성(inheritance)
3 다형성(polymorphism)
4 추상화(abstraction)

캡슐화
- 실제로 구현되는 부분을 외부에 드러나지 않도록 캡슐로 감싸 이용방법만을 알려주는것
- 은닉화또한 캡슐화의 한부분이다
실제로 구현되는 부분을 외부에 드러나지 않도록 캡슐로 감싸 이용방법만을 알려주는것이 캡슐화의 중요 컨셉이다.
그리고, 이 캡슐화(encapsulration) 과정에서 데이터들과, 여러 로직들이 은닉이 된다.
말그래도  캡슐(encapsulration)로 감싸 숨기(은닉화 , hiding)는 것이다.
*은닉화 
1.은닉이란 내부 데이터, 내부 연산을 외부에서 접근하지 못하도록 
은닉(hiding) 혹은 격리(isolation)시키는 것을 의미한다.
2.변수에 접근지정자를 private 로 지정한다.
3.setter , getter 를 사용해 변수의 접근,제어한다.

은닉화는 캡슐화에 비해 비교적 구체적인 개념이다.
 
은닉화는 캡슐화의 한 개념으로 객체 외부에서 객체내의 자료로의 접근을 제한하고 데이터를 수정,조작하는 동작은
내부에 두고 접근(getter),설정(setter)하는 메소드로 결과만 받는것이다.
이렇게 되면 외부에서는 내부적인 움직임을 알수가 없으며 데이터에 어떤값이 있는지 또는 어떤 변화가 일어나는지 알수없다.  단지 데이터의 접근을 메서드(setter , getter)를 통해 결과만 받을뿐이다. 이런한 것을 은닉화라 한다.

은닉화와 캡슐화의 차이
 
1.은닉화는 중요사항이(변수던 메소드던간에)밖으로 드러나지 않도록 꼭꼭 감추는것
2.캡슐화는 중요사항을 감춘 상태에서 외부에 그것을 사용할수 있는 방법을 설정하고 외부와 직접적으로 의사소통을 의미 한다

(한마디로 맛집에서 비밀소스의 제조법을 안알려주나 따로 판매는 하는 느낌이다...)
 
출처:http://blog.houkibosi.com/entry/%EC%BA%A1%EC%8A%90%ED%99%94%EC%99%80-%EC%9D%80%EB%8B%89%ED%99%94
참고:http://blog.naver.com/echris7/140023022776
 
상속 
- 상위 개념의 특징을 하위 개념이 물려받는 것
- 상위객체의 메소드를 그대로 물려받아 재사용하면서 새로운 객체를 만드는 방법

다형성 
- 같은 이름의 함수 호출에 대하여 각 객체에 따라 다른 동작을 할 수 있도록 구성하는 방법.
- 하나의 변수로 여러타입의 객체를 가질 수 있는 것
 
추상화 
- 추상화 작업을 통해 실세계 상황을 간결하고, 명확하게 모델링하면, 그것을 프로그램으로 실체화 즉 구현
- 객체지향에서는 클래스를 이용, 실세계에 대응하는 추상모델 만듦.
- 객체들의 공통적인 특징(속성 과 기능)을 뽑아내는 것이다.
[출처] 1.OOP(Object Oriented Programming) 객체지향프로그래밍|작성자 dandelion

################################################################################
################################################################################
2 General Questions about Java
################################################################################
2.1 What is JVM ? Why is Java called the Platform Independent Programming Language?
 Java 가상 머신 (JVM)은 Java 바이트 코드 를 실행할 수 있는 프로세스 가상 머신 입니다 . 
각 Java 소스 파일은 JVM에 의해 실행되는 바이트 코드 파일로 컴파일됩니다. 
Java는 각 플랫폼마다 프로그래머가 다시 작성하거나 다시 컴파일하지 않고도 모든 플랫폼에서 실행할 수있는 응용 프로그램을 작성할 수 있도록 설계되었습니다. 
자바 가상 머신은 특정 명령 길이와 기본 하드웨어 플랫폼의 다른 특수성을 알고 있기 때문에이를 가능하게합니다.

################################################################################
2.2 What is the Difference between JDK and JRE ?
JDK : Java Development Kit
자바 개발도구입니다. 자바 프로그래밍을 할 때 필요한 컴파일러 등이 들어 있습니다. 자바 프로그래머가 아닌 일반인은 다운로드받을 필요가 없습니다.
JDK 를 설치했다면 아래의 JRE도 같이 설치됩니다.

JRE : Java Runtime Environment
컴파일된 자바 프로그램을 실행시킬 수 있는 자바 환경을 만드는 것입니다.
자바 프로그램을 실행시키려면 JRE 를 반드시 설치해야 합니다.
JRE 안에 자바 프로그래밍 도구는 없습니다. 자바 프로그래밍을 하기 위해서는 위의 JDK를 받아야 합니다. 둘 다 무료입니다.

################################################################################
2.3 What does the “static” keyword mean ? Can you override private or static method in Java ?
http://infraking.tistory.com/103
static 변수(즉 정적변수)란  
- Class 당 하나만 생성되는 변수, 객체(인스턴스)를 아무리 많이 만들더라도 변수는 하나만 존재 
- 객체가 생성될 때마다 새롭게 생성되는 멤버 변수와는 달리 초기에 한번만 생성되고 공유하여 사용가능 

################################################################################
2.4 Can you access non static variable in static context ?
Java의 정적 변수는 해당 클래스에 속하며 그 값은 모든 인스턴스에 대해 동일하게 유지됩니다. 
정적 변수는 클래스가 JVM에 의해로드 될 때 초기화됩니다. 
코드가 어떤 인스턴스도없이 비 정적 변수에 액세스하려고하면 해당 변수가 아직 만들어지지 않았기 때문에 컴파일러가 불평 할 것입니다.

################################################################################
2.5 What are the Data Types supported by Java ? What is Autoboxing and Unboxing ?
http://hyeonstorage.tistory.com/135

java에는 크게 기본형, 참조형 변수 두 종류가 있습니다.
기본형은 boolean, char, byte, short, int, long, float, double와 같이 계산을 할 수 있는 타입이며,
참조형은 기본형을 제외한 나머지 타입을 의미합니다. String, StringBuffer, List 등등 개인이 만든 클래스도 참조형 타입이 될 수 있습니다.
출처: http://manducku.tistory.com/37 [Manducku`s Code]
JAVA에는 8개의 기본 데이터 타입(primitive data types)이 있다.
8bit = 1byte 
1 byte의 범위는 -128 ~ 127
정수 타입 : byte(1byte), short(2byte), int(4byte), long(8byte)
부동 소수점 타입 : float(4byte), double(8byte)
부울 데이터 타입 : boolean(1byte)
문자 데이터 타입 : char(2byte)

자바 - 오토박싱/언박싱
기본형에 상응되는 Wapper클래스 타입간의 자료 변환작업이 불필요할 정도로 많은 코드를 용구하는 경우가 있다.
5.0에서는 int와 Integer간의 변환작업을 컴파일러가 맡아서 처리하므로 불필요함을 크게 줄었다.
5.0에서 이러 귀찮은 변환작업을 자동으로 제공하는 이를 오토박싱/언박싱이라고 한다.

int a = 5;
Integer it = new Integer(a); ==> 객체
int i = it.intValue() => 개체 -> 기본형
====================================== 이런 번거러운 작업이...5.0이후로 개선되어
1. AutoBoxing : 기본형 => 오브젝트형 자동 변환
Integer it = a; ==> 숫자 a에 박스가 쉬어져 it라는 오브젝트가 되어짐
2. unBoxing : 오브젝트형 => 기본형으로 자동 변환
int i = it ; 

################################################################################
2.6 What is Function Overriding and Overloading in Java ?
1 Overloading(오버로딩) 중복정의
- 같은 이름의 메소드를 여러개 정의하는 것
- 매개변수의 타입이 다르거나 개수가 달라야 한다.(매개변수의 수, 배치(순서)등)
* return type과 접근 제어자는 영향을 주지 않음.

2 Overriding(오버라이딩) 재정의

자식클래스에서 오버라이딩하는 메서드는 부모클래스의 메서드와
- 이름이 같아야 함
- 매개변수가 같아야 함
- 리턴타입이 같아야 함

접근제한자는 부모클래스와 같거나 더 넓게 지정해야 함
 
 * 접근제한자의 넓은개념부터의 순서 : public > protected > default(생략한 경우) > private

################################################################################
2.7 What is a Constructor, Constructor Overloading in Java and Copy-Constructor . . . . . . . . . . . . . . . . . . . 4
자바에서 constructor 생성자는 객체를 초기화 하기 위해 사용하는 메소드의 특별한 타입입니다.
#생성자(constructor)
- 클래스를 대상으로 객체를 생성하는 역할 
- 클래스의 이름과 동일 
- 메소드의 형태를 갖는다 -> but, 리턴타입은 없다. 
- 반드시 모든 클래스는 1개 이상의 생성자가 존재  
   -> 생성자가 없으면 JVM이 기본 생성자를 만든다.
#생성자의 용도
 1. 객체 생성 역할 
 2. 멤버변수 초기화 
 3. 객체 생성 시점에서 자동 처리할 내용 
   -> 생성자는 객체 생성 시점에서 1회만 호출됨(new명령어 사용시점) 
################################################################################
2.8 Does Java support multiple inheritance ? 
메소드 오버라이딩을 할 때 어떤 슈퍼클래스의 메소드를 오버라이딩 하려고 하는지 자바는 알 수 없습니다. 이런 문제 때문에 클래스는 다중상속을 할 수 없습니다.
인터페이스는 일반 클래스처럼 메소드가 어떤 행동을 하는지는 기술하지 않습니다. 추상화된 메소드이기 때문이죠.
(이 때 다중상속은 인터페이스와 인터페이스 사이에서만 가능합니다.)

################################################################################
2.9 What is the difference between an Interface and an Abstract class ? . . . . . . . . . . . . . . . . . . . . . . . . . 4
1 Interface
- 오직 추상메서드와 상수만을 멤버로 갖는다.
- Implements 키워드를 사용
- Extends는 하나의 클래스만 상속 가능하나 Interface는 다중 상속이 가능하다.

2 Abstract Class
- 추상메서드를 하나 이상 가진 클래스 (구상 메서드 포함 가능)
- 하위 클래스를 참조하여 상위 클래스의 객체를 생성
- 하위 클래스를 제어하기 위해 사용

공통점 
- new 연산자로 인스턴스 생성 불가능.

3 Abstract Method
-함수의 body부분({})이 없는 미완성의 함수
-상속받은 클래스는 반드시 상위클래스의 추상메소드를 구현해야만 한다.

################################################################################
2.10 What are pass by reference and pass by value ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1) call-by-value 
- 메서드 호출 시 기본 자료형의 값을 인자로 전달하는 방식
- 호출 시의 실인자는 별도의 값으로 인식되어 영향을 받지 않음

 2) call-by-reference (call-by-reference 를 지원안함)
- 메서드 호출 시 전달하려는 인자를 참조(객체) 자료형을 사용한 경우를 의미
- 하나의 객체를 참조하는 변수가 2개가 되어 어느 한 곳에서 수정을 하게 되면 같은 객체를 참조하는 다른 쪽에서도 영향을 받게 됨.
################################################################################
################################################################################
3 Java Threads
################################################################################
3.1 What is the difference between processes and threads ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
프로세스는 실행될 때 운영체제로부터 프로세서를 할당받고, 운영되기 위해 필요한 주소 공간, 메모리 등 자원을 할당받습니다. 
스레드란 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들을 같은 프로세스 내에 스레드끼리 공유하면서 실행됩니다.
그러니까 프로세스와 스레드에 대한 질문은 결국에는 운영체제가 시스템의 자원을 어떤 단위로 할당하고, 프로세스와 스레드는 이 자원을 어떻게 사용하느냐를 알고 있냐에 대한 질문입니다.

그렇다면 왜, 여러 프로세스(멀티 프로세스)로 할 수 있는 작업들을 굳이 하나의 프로세스에서 스레드로 나눠가면서 할까요? 
이유는 굉장히 1차원 적입니다. 
운영체제는 시스템 작업을 효율적으로 관리하기 위한 것이므로 이 목적을 더 크게 달성하기 위해서 스레드를 사용하는 것이죠. 

자세히 말씀드리자면 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 
프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다. 
뿐만 아니라 프로세스간의 통신보다 스레드 간의 통신의 비용이 적으므로 작업들 간의 통신의 부담이 줄어들게 됩니다.
이처럼 스레드를 활용하면 자원의 효율성이 증가하기도 하지만 스레드 간의 자원 공유는 전역 변수를 이용하므로 동기화 문제에 신경을 써야 합니다. 
때문에 멀티스레드 프로그래밍은 프로그래머의 주의를 요구합니다.

다시 한번 말씀드리지만 위 질문에 대한 key point는 운영체제에서 작업을 실행할 때 자원을 할당하는 단위를 알고 있느냐와 프로그램을 멀티 스레드를 구현할 때 장.단점을 알고 있느냐에 대한 질문입니다.

################################################################################
3.2 Explain different ways of creating a thread. Which one would you prefer and why ? . . . . . . . . . . . . . . . . 6
자바 쓰레드Java Thread의 정의를 알기 전에 프로세스Process에 대해 알아야 합니다. 
보통 우리가 만드는 프로그래밍 언어Java, C/C++ 등로 소스를 짜서 만든 것을 "프로그램"이라고 합니다. 
그리고 이 프로그램을 "실행" 시켜서 동작하게 만들면 이것을 "프로세스"라고 합니다. 
이 프로세스는 보통 하나의 루틴프로그램 처리 경로을 가지고 있습니다. 이 루틴은 직렬적입니다. 
즉 어떠한 일을 수행하는 것에 있어 프로그래머가 원하는 순서대로 일을 처리합니다. 
그러나 생각해보면 굳이 앞뒤 순서가 필요 없는 일들이 있을 때 분리해서 동시에 처리하고 싶은 생각이 들 때가 있습니다. 
이 때 자바에서 사용할 수 있는 것이 쓰레드Thread입니다.
자바 쓰레드를 이용하면 하나의 프로세스에서도 병렬적으로 처리, 즉 여러 개의 처리 루틴을 가질 수 있습니다. 
단순 반복의 코드를 실행할 때도 여러 개의 쓰레드를 만들어서 분리 시킨 뒤 결과 데이터를 받아 합치면 그만큼 시간을 절약할 수 있습니다.

Thread 클래스를 상속 받는 것
① Thread 클래스를 상속받은 후, run() 메소드를 원하는 작업을 하도록 오버라이딩
② 완성된 클래스를 생성한 후, start() 메소드를 실행
void start()	쓰레드 생성하고 run() 메소드를 실행시키는 메소드
void run()	쓰레드가 할 일을 정의한 메소드
String getName()	쓰레드의 이름을 반환
void setName()	쓰레드의 이름을 설정
void sleep(long millis)	1000분의 millis 초 만큼 쓰레드를 중지시킨 후, 재실행
boolean isAlive()	쓰레드가 살아있는지 확인

Runnable 인터페이스 구현
① Runnable 인터페이스를 상속받은 후, run() 메소드를 원하는 작업을 하도록 구현
② 완성된 클래스를 생성한 후, Thread 클래스의 생성자에게 인수로 전달

Thread 클래스를 상속받아 클래스를 만드는 경우에는 해당 클래스의 start() 메소드를 직접 호출했지만, 
Runnable 인터페이스를 상속받는 경우에는 Runnable 인터페이스로 구현한 클래스의 객체를 인수로 주어 Thread 클래스의 객체를 생성한 후, 
생성된 Thread 객체의 start() 메소드를 호출해주어야 합니다.
Thread 클래스의 생성자는 Runnable 인터페이스의 서브클래스를 인수로 받으면, 해당 클래스의 run() 메소드를 실행하는 쓰레드를 만듭니다.

################################################################################
3.3 Explain the available thread states in a high-level.
New : new 키워드로 인스턴스화된 상태
Runnable : start 메소드가 호출되어 실행 준비를 마친 상태
Blocked : 쓰레드 실행 중에 sleep 혹은 join 메소드가 호출되어 잠시 멈춘 상태
Dead : run 메소드가 완료되어 실행이 완전히 종료된 상태

################################################################################
3.4 What is the difference between a synchronized method and a synchronized block ?
3.5 How does thread synchronization occurs inside a monitor ? What levels of synchronization can you apply ? 
자바에서는 스레드를 동기화 하기 위해서 synchronized를 제공한다.
스레드는 synchronized 메소드에 들어가기 위해 lock을 얻고 메소드가 끝이나면 lock을 반환한다. 
어떠한 스레드가 lock을 얻어 synchronized 메소드를 사용중이면 다른 메소드는 lock이 없으므로 synchronized에 접근할 수 없고, 
다른 스레드가 lock을 반환 할 때까지 기다려야 한다.

실제로 위와 같은 작업은 JVM에 의해 자동으로 수행되기 때문에 우리는 synchronized 메소드를 이용하기만 하면 된다.

synchronized를 이용하는 방법은 2가지가 있다.
1. synchronized method 방법
메소드 앞에 synchronized 키워드를 붙여주면 간단하게 사용할 수 있다.
public synchronized 메소드명(파라미터) { ... }

2. synchronized block 방법
synchronized 메소드와 기능은 유사하다. 파라미터가 공유할 객체로 들어간다.
synchronized (공유할 객체) { ... }

################################################################################
3.6 What’s a deadlock ?
교착상태는 동일한 자원을 공유하고 있는 두 개의 컴퓨터 프로그램들이, 상대방이 자원에 접근하는 것을 사실상 서로 방해함으로써, 
두 프로그램 모두 기능이 중지되는 결과를 낳는 상황을 말한다.
이 상황에서, 단 하나의 대안은 두 프로그램 중의 하나를 강제로 종료시키는 것이다. 

################################################################################
3.7 How do you ensure that N threads can access N resources without deadlock ?
N 스레드를 사용하는 동안 교착 상태를 피하는 간단한 방법은 잠금에 순서를 지정하고 각 스레드가 해당 순서를 따르도록하는 것입니다. 
따라서 모든 스레드가 뮤텍스를 동일한 순서로 잠그고 잠금 해제하면 교착 상태가 발생할 수 없습니다.

################################################################################
################################################################################
4 Java Collections 8
################################################################################
4.1 What are the basic interfaces of Java Collections Framework ? . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
Java에서 데이터를 저장하는 기본적인 자료구조들을 한 곳에 모아 관리하고 편하게 사용하기 위해서 제공하는 것을 의미한다. 
다음은 JCF의 상속 구조이며 사용 용도에 따라 List, Set, Map 3가지로 요약할 수 있다.
Collection  ->  List    ->  LinkedList(링크드리스트)
                            Stack(스택자료구조)
                            Vector(동기화보장)
                            ArrayList(동기화 보장하지 않음)
Collection  ->  Set     ->  HashSet(Set계열의 대표클래스)
                        ->  SortedSet   -> TreeSet
Map         ->  Hashtable
            ->  HashMap
            ->  SortedMap   ->  TreeMap 

List 인터페이스 (LinkedList, Stack, Vector, ArrayList 구현클래스) 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다.
Set 인터페이스 (HashSet, TreeSet 구현클래스) 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다.
Map 인터페이스 (HashMap, TreeMap, HashTable, Properties) 키와 값의 쌍으로 이루어진 데이터의 집합니다. 순서는 유지되지않고, 키는 중복을 허용하지 않으며 값은 중복을 허용한다.

 ■ Collection Interface
: 모든 콜렉션의 상위 인터페이스로써 콜렉션들이 갖고 있는 핵심 메소드를 선언 (add, contain, isEmpty, remove, size, iterator ...)

List Interface 
: Collection 인터페이스를 확장한 자료형으로 요소들의 순서를 저장하여 색인(Index)를 사용하여 특정 위치에 요소를 삽입하거나 접근할 수 있으며 중복 요소 허용

ArrayList
상당히 빠르고 크기를 마음대로 조절할 수 있는 배열
단방향 포인터 구조로 자료에 대한 순차적인 접근에 강점이 있음

Vector
ArrayList의 구형버전이며, 모든 메소드가 동기화 되어있음
잘 쓰이진 않음

LinkedList
양방향 포인터 구조로 데이터의 삽입, 삭제가 빈번할 경우 빠른 성능을 보장.
스택, 큐, 양방향 큐 등을 만들기 위한 용도로 쓰임

Set Interface
: 집합을 정의하며 요소의 중복을 허용하지 않음. 상위 메소드만 사용함

HashSet
가장 빠른 임의 접근 속도
순서를 전혀 예측할 수 없음

LinkedHashSet
추가된 순서, 또는 가장 최근에 접근한 순서대로 접근 가능

TreeSet
정렬된 순서대로 보관하며 정렬 방법을 지정할 수 있음

 ■ Map Interface
: Key와 Value의 쌍으로 연관지어 저장하는 객체

HashMap
Map 인터페이스를 구현하기 위해 해시테이블을 사용한 클래스
중복을 허용하지 않고 순서를 보장하지 않음
키와 값으로 null이 허용

Hashtable
HashMap 보다는 느리지만 동기화가 지원
키와 값으로 null이 허용되지 않음

TreeMap
이진검색트리의 형태로 키와 값의 쌍으로 이루어진 데이터를 저장
정렬된 순서로 키/값 쌍을 저장하므로 빠른 검색이 가능
저장시 정렬(오름차순)을 하기 때문에 저장시간이 다소 오래 걸림

LinkedHashMap
기본적으로 HashMap을 상속받아 HashMap과 매우 흡사
Map에 있는 엔트리들의 연결 리스트를 유지되므로 입력한 순서대로 반복 가능

################################################################################
4.2 Why Collection doesn’t extend Cloneable and Serializable interfaces ?

################################################################################
4.3 What is an Iterator ?
Iterator는 자바의 컬렉션 프레임웍에서 컬렉션에 저장되어 있는 요소들을 읽어오는 방법을 표중화 하였는데 그 중 하나가 Iterator이다.
public interface Iterator {
boolean hasNext();
Object next();
void remove();
}
Iterator 는 자동으로 Index 를 관리해주기 때문에, 사용에 편리함이 있을수 있으나 Iterator 를 열어보면 객체를 만들어 사용하기 때문에 느릴수 밖에 없다.
그러므로, list 의 size를 받아와서 사용것이 더 좋다.

################################################################################
4.4 What differences exist between Iterator and ListIterator ?
ListIterator는 Iterator를 상속한 인터페이스입니다.
Collection에서 제공하는 Iterator인터페이스는  Collection을 한방향으로 탐색하면서 객체에 대한 정보를 얻어냅니다.
 ListIterator는 List에서 제공하는 인터페이스로 List에 포함된 모든 객체를 양방향으로
탐색하면서 객체를 꺼낼 수 있는 방법을 제공하고 있습니다.
프로그래머는 ListIterator 이용하면 양방향으로 움직여가면서 수정이라던가,iterator의
현재 위치를 알아낼수 있습니다. List를 사용하는 경우에는 Collection에서 제공하는 Iterator
는 물론이거니와 보다 확장된 기능을 갖고 있는 ListIterator를 사용할 수 있습니다.

################################################################################
4.5 What is difference between fail-fast and fail-safe ?
콜렉션 클래스들은 저장된 객체들에 대한 순차적 접근을 제공한다.
그러나, 순차적 접근이 모두 끝나기 전에 콜렉션 객체에 변경이 일어날 경우 순차적 접근이 실패되면서 ConcurrentModificationException 예외를 return하게 되는데 이를 fail-fast 방식이라고 부른다.

Enumeration은 순차적 접근 시 콜렉션 객체에 변경이 일어나도 이를 무시하고, 끝까지 동작하는 반면에Iterator는 fail-fast 방식으로 동작한다.

Iterator의 fail-fast 속성은 다음 엘리먼트에 접근 하려고 할 때 엘리먼트가 변한것이 있는지 확인하는 것이다. 
만약 수정 사항이 발견된다면 ConcurrentModificationException를 발생시킨다. 
모든 Iterator의 구현체는 ConcurrentHashMap이나 CopyOnWriteArrayList 동시성 관련된 컬렉션을 제외 하고 처럼 fail-fast를 사용하는 방법으로 디자인 되어 있다.
 
fail-fast를 사용하는 방식의 컬렉션들은 java.util 패키지에 들어가있고 fail-safe는 java.util.concurrent 패키지에 위치하도록 디자인되어 있다. 
Fail-fast Iterator는 ConcurrentModificationException 을 발생 시키고 
fail-safe는 절대로 ConcurrentModificationException를 발생 시키지 않다.

################################################################################
4.6 How HashMap works in Java ?
HashMap이란 Map인터페이스의 한종류로써 Key와 Value 값으로 데이터를 저장하는 형태를 가지고 있습니다.
Map에 종류에는 Hashtable, HashMap, LinkedHashMap, SortedMap, TreeMap 등이 있습니다.
해싱(hashing)이란 검색 방법을 사용하기 때문에 많은 양의 데이터를 검색하는데 있어서 뛰어난 성능을 보여줍니다.

HashMap 은 키-값 쌍으로 사용하도록 구현되어 있다. 
HashMap은 해싱 알고리즘을 사용하고 hashCode()와 equals()를 put() 과 get()을 쓸대 사용한다. 
키-값 을 저장하기 위해 put 메서드를 호출 하면 HashMap은 key의 hashCode()를 호출해서 맵에 저장되어 있는 값 중에 동일한 key가 있는지 찾는다. 
이 Entry는 LinkedList에 저장되어 있고 만약 존재하는 entry면 equals()메서드를 사용해서 key가 이미 존재 하는지 확인 하고 만약 존재 한다면 value값을 덮어 씌워서 새로운 키-값 으로 저장한다. 
키를 가지고 get 메서드를 호출하면 hashCode()를 호출해서 array에서 값을 찾고 equals()메서드를 가지고 찾고자 하는 key와 동일한지 확인한다. 

HashMap에 대해 알아야할 다른 중요한 것은 capacity, load factor, threshold resizing이다. 
HashMap은 기본적으로 capacity 는 32, load factor는 0.75로 세팅하고 Threshold는 entry를 추가할 때 마다 capacity에 load factor를 곱한 값이 된다. 
만약 map이 크기가 threshold 보다 크면 HashMap은 더 큰 capacity를 사용하도록 맵을 재 해시한다. 
capacity는 항상 데이터베이스의 데이터를 캐싱하는 것 같은 많은 수의 key-value 쌍을 저장할때 알아야된다. 
이것은 HashMap을 적절한 capacity 와 load factor를 사용해서 초기화 하는 좋은 방법이다.

################################################################################
4.7 What is the importance of hashCode() and equals() methods ?
equals 는 두 객체의 내용이 같은지, 동등성(equality) 를 비교하는 연산자
hashCode 는 두 객체가 같은 객체인지, 동일성(identity) 를 비교하는 연산자

HashMap은 Key 오브젝트의 hashCode()와 eqauls()메서드를 사용해서 key-value 값을 저장할 위치를 결졍하고 HashMap에서 값을 꺼내올때도 사용한다. 
만약 이 메서드들이 올바르게 구현되지 않았다면 다른 두개의 Key가 같은 hashCode() 및 eqauls() 결과를 내놓을 수 있고 이는 value 값들을 잘못된 의도하지 않은 값으로 덮어 씌울 가능성이 있다. 
equals()와 hashCode()의 구현은 아래 기본룰을 따라야 된다.
If o1.equals(o2), then o1.hashCode() == o2.hashCode()should always be true.
If o1.hashCode() == o2.hashCode is true, it doesn’t mean that o1.equals(o2) will be true.

################################################################################
4.8 What differences exist between HashMap and Hashtable ?
일반적으로 동기화가 필요 없다면 HashMap을, 동기화 보장이 필요하다면 Hashtable을 사용하면된다.
HashMap 은 Map 인터페이스 계열의 대표적인 클래스이다. 
키(Key)와 값(Value)으로 데이터를 관리하며 키를 이용하여 데이터를 추출할 수 있다.

################################################################################
4.9 What is difference between Array and ArrayList ? When will you use Array over ArrayList ?
Arrays는 고정 크기이고 an ArrayList은 동적입니다.
ArrayList더 많은 방법과 기능 등 제공 addAll, removeAll, iterator, 등
원시 데이터 형식의 목록을 보려면 콜렉션에서 autoboxing을 사용하여 코딩 작업을 줄입니다. 
그러나 이 방법은 고정 크기 기본 데이터 형식에서 작업 할 때 속도가 느려집니다.

Array는 변수를 담는 구조로 자주 사용됩니다. 
        Array                               ArrayList
사이즈   초기화시 고정                             초기화시 사이즈를 표시하지 않음. 유동적
        int[] myArray = new int[6];         ArrayList<Integer> myArrayList = new ArrayList<>();
속도     초기화시 메모리에 할당되어 속도가 빠르다. 추가시 메모리를 재할당하여 속도가 느리다.
변경     사이즈 변경 불가                           추가 삭제 가능 add(), remove() 로 가능
다차원   가능                                       불가능 
        int[][][] muttiArray = new int [3][3][3]; 

################################################################################
4.10 What is difference between ArrayList and LinkedList ?
Vector – 구버젼 호환용. 그다지 사용되지 않음. 동기화 처리가 내부적으로 일어남으로 다른 객체보다 무거움.
ArrayList – 배열의 복사에 의한 데이터 저장처리를 내부적으로 행하며, 각 데이터에 대한 인덱스를 가지고 있기때문에 검색이 매우 빠르다. 
              다만, 많은 데이터의 추가 / 삭제시에는 배열의 복사가 빈번하게 일어나, 성능이 떨어지는 단점이 있다.
LinkedList – 다음 자료의 위치정보를 가지며, 내부적인 인덱스는 가지고 있지않다. 
               데이터의 추가 / 삭제는 위치정보의 수정만으로 가능하기 때문에 많은 정보의 추가 / 삭제처리가 필요할때 유용하다. 
               다만, 데이터가 많은 경우의 검색시 처음 자료로부터 순차적으로 찾아 나가야 하기 때문에 느려지는 단점이 있다.

################################################################################
4.11 What is Comparable and Comparator interface ? List their differences
Comparable 인터페이스 객체의 비교를 위한 인터페이스로 객체간에 순서나 정렬을 하기 우해서 Comparable 인터페이스를 구현해야 한다.
구현하는 방법은 Comparable 인터페이스를 객체비교를 구현할 클래스에 implements (상속)하고, int compareTo(T o) 메소드를 재정의 해야한다. 
이때 재정의 하면서 내부적으로 객체를 비교하여 어떻게 순서가 정해질지에 대해서 구현하면 된다.

Comparator 인터페이스는 Comparable 인터페이스처럼 객체비교를 구현하기 위한 인터페이스이다.
객체 비교를 위해서 int compare(T o1, T o2) 메소드를 재정의해야 한다.

################################################################################
4.12 What is Java Priority Queue ?
Queue라는 자료구조는 '선입선출'(First-In, First-Out)의 대기열 규칙(queuing discipline)을 가지고 있다. 말그대로 먼저들어온 놈이 먼저 나간다는 것이다.
하지만 JAVA에서 제공하는 'PriorityQueue'는 우선순위를 결정하여 들어온 순서와 상관없이 그 우선순위가 높은 엘리먼트가 나가게 된다

################################################################################
4.13 What do you know about the big-O notation and can you give some examples with respect to different data structures ?
계산 복잡도 이론에서 사용되는 점근 표기법. 
컴퓨터 과학에서는 주로 입력 데이터의 크기와 알고리즘의 소요 시간 또는 메모리의 상관관계를 나타내지만, 
엄밀히는 임의의 함수에 대하여 "함수의 입력값(정의역의 원소)이 커짐에 따라 그 출력값(그 원소의 상)이 얼마나 빠르게 커지는가"를 표현한다. 
예를 들어, n개의 자연수를 병합 정렬로 정렬하기 위해서는
O(nlgn)의 시간이 소요된다.
O(n)의 공간을 사용한다.
그러나 알고리즘을 평가할 때는 대체로 그 시간과 공간의 사용량이 주된 관심사가 되고 그 중에서도 특히 시간에 신경을 많이 쓰기 때문에, "병합 정렬은 O(nlgn) 알고리즘이다

################################################################################
4.14 What is the tradeoff between using an unordered array versus an ordered array ?
정렬 된 배열의 가장 큰 장점은 정렬 시간이 O (log n) 인 검색 시간이 O (n) 인 정렬되지 않은 배열보다 검색 시간이 복잡하다는 것입니다. 
정렬 된 배열의 단점은 삽입 연산에 O (n)의 시간 복잡도가 있다는 것입니다. 
왜냐하면 더 높은 값을 가진 요소가 새 요소를위한 공간을 만들기 위해 이동되어야하기 때문입니다. 
대신, 순서가없는 배열에 대한 삽입 작업은 O (1)의 일정 시간이 걸립니다.

################################################################################
4.15 What are some of the best practices relating to the Java Collection framework ?
- 객체지향 프로그래밍에서도 알고리즘과 데이터 구조는 매우 중요
객체 내부를 구현하는데 있어서 얼마나 적합한 알고리즘을 사용하느냐와 데이터 구조를 사용하느냐가 매우 중요.
복잡한 프로그램 제작을 위해 다양한 종류의 데이터 구조가 요구됐고, 이러한 요구에 따라 자바2 부터 등장한 것이 Java Collection Framework이다.
- 컬렉션을 사용함으로써 얻는 장점은 다음과 같다.
1> 자료구조를 구현하는데 드는 시간과 노력을 덜어준다.
: 자료구조를 구현하는 일이 쉬운 일은 아니다. 컬렉션 프레임웤에서는 필수적으로 필요한 자료구조를 구현하여 제공하고 있다.
2> 표준적인 방법을 제시함으로써 API숙지에 필요한 시간을 절감
:자바 프레임웤이 나오기 전에는 회사마다 구현한 자료구조를 구해 사용해야 했음. 따라서 각 회사마다의 API 를 숙지해야 하는 번거로움이 있었음
3> 좋은 성능을 기대할 수 있다. 

################################################################################
4.16 What’s the difference between Enumeration and Iterator interfaces ?
Iterator, Enumeration은 둘다 모두 자바에서 제공하는 컬렉션에 대해 각 컬렉션의 항목들을 순차적으로 접근하는데 사용한다.
차이점은 Enumeration의 경우 자바의 초기버젼에서 개발되었습니다. 
자바는 jdk1.2, 즉 자바2에서 많은 변화가 생겼는데, 그중에 하나가 컬렉션 클래스(Vector, List, Map, Set...)들을 컬렉션프레임웍 이라는것으로 관리하는것이다.
이때, 컬렉션프레임웍에서는 Iterator라고 해서, Enumeration의 기능을 확장해서, Collection인터페이스를 상속받은 모든 컬렉션(List, Set, Vector.)에서 Enumeration을 사용가능하게 하였다.
정리하면, 
Enumeration는 자바초기버젼에서 제공되는것으로 Hashtable, Vector 에서 사용가능하다. 
Iterator는 jdk1.2에서 제공되는 것으로 Collection인터페이스를 구현상속한 모든 컬렉션 클래스에서 사용가능하다.

################################################################################
4.17 What is the difference between HashSet and TreeSet ?
HashSet해시 테이블을 이용하여 구현되며 요소는 정렬되지 않는다. add, remove 및 contains 메소드 HashSet에는 일정 시간 복잡도 O(1). 
TreeSet는 트리 구조를 사용하여 구현되며 요소는 정렬된다. add, remove 및 contains 메소드의 시간 복잡도는 O(logn)입니다.

HashSet 동기화 X 가장 빠른 접근 보장(집합), HashMap보다 느림 내부적으로 HashMap을 이용(키값으로 저장)
LinkedHashSet set에 삽인된 순서를 부여하기 위해 1.4부터 등장
TreeSet 동기화 X HashSet 보다 느림, comparator에 의해 원소가 정렬됨, set의 항목들을 정렬된 순서대로 보관.
################################################################################
################################################################################
5 Garbage Collectors (참고 http://d2.naver.com/helloworld/1329)
################################################################################
5.1 What is the purpose of garbage collection in Java, and when is it used ?
가비지 콜렉션의 목적은 자원이 재사용 될 수 있도록 응용 프로그램이 더 이상 필요하지 않은 오브젝트를 식별하고 버리는 것입니다.

메모리의 힙 영역에 할당된 더 이상 사용되지 앟는 객체를 다른 객체가 사용할 수 있도록 제거
가비지 컬렉션의 특징
1. 자동 메모리 관리 automatic memory management라 부르기도 한다.
2. 가비지 컬렉션은 프로그래머가 구현할 수 없다.
3. 가비지 컬렉션의 대상은 객체이지 참조가 아니다.
4. 가비지 컬렉션의 대상은 살아있는 스레드가 더이상 참조하지 않는 객체이다.
5. 다른 참조 변수도 참조하고 있는 객체는 가비지 컬렉션의 대상이 될 수 없다.
6. 객체에 할당된 메모리를 명시적으로 해체할 수 없다.
7. 가비지 컬렉터가 객체를 어떠한 순서로 정리하는지는 알 수 없다.
8. 가비지 컬렉터가 언제 수행될지 정확히 알 수 없다.
9. 가비지 컬렉션의 실행은 JVM이 결정하며 우리는 단지 요청만 할 수 있다.

################################################################################
5.2 What does System.gc() and Runtime.gc() methods do ?
어떤 객체가 가비지 컬렉션의 대상이 된다고 해서 가비지 컬렉터가 바로 이 객체의 메모리를 해지하는 것은 아니다. 
가비지 컬렉션은 자바가상머신이 판단에 따라 동작하므로 사용자가 이를 강제할 수는 없다. 
다만 다음과 같은 방법으로 가비지 컬렉터에게 가비지 컬렉션을 요청할 수는 있다.
1. System.gc();
2. Runtime.getRuntime().gc();

################################################################################
5.3 When is the finalize() called ? What is the purpose of finalization ?
finalize 메서드는 객체의 메모리를 해제하기 전에 가비지 수집기에서 호출합니다. 
일반적으로 finalize 메소드 내에서 객체가 보유한 자원을 해제하는 것이 좋습니다.

################################################################################
5.4 If an object reference is set to null, will the Garbage Collector immediately free the memory held by that object ?
아니요. 개체는 다음주기의 가비지 수집기에서 가비지 수집을 위해 사용할 수 있습니다.

################################################################################
5.5 What is structure of Java Heap ? What is Perm Gen space in Heap ?
Young 영역(Yong Generation 영역): 
    새롭게 생성한 객체의 대부분이 여기에 위치한다. 
    대부분의 객체가 금방 접근 불가능 상태가 되기 때문에 매우 많은 객체가 Young 영역에 생성되었다가 사라진다. 
    이 영역에서 객체가 사라질때 Minor GC가 발생한다고 말한다.
Old 영역(Old Generation 영역): 
    접근 불가능 상태로 되지 않아 Young 영역에서 살아남은 객체가 여기로 복사된다. 
    대부분 Young 영역보다 크게 할당하며, 크기가 큰 만큼 Young 영역보다 GC는 적게 발생한다. 
    이 영역에서 객체가 사라질 때 Major GC(혹은 Full GC)가 발생한다고 말한다.
    
Young 영역의 구성
GC를 이해하기 위해서 객체가 제일 먼저 생성되는 Young 영역부터 알아보자. Young 영역은 3개의 영역으로 나뉜다.
Eden 영역
Survivor 영역(2개)
Survivor 영역이 2개이기 때문에 총 3개의 영역으로 나뉘는 것이다. 각 영역의 처리 절차를 순서에 따라서 기술하면 다음과 같다.
새로 생성한 대부분의 객체는 Eden 영역에 위치한다.
Eden 영역에서 GC가 한 번 발생한 후 살아남은 객체는 Survivor 영역 중 하나로 이동된다.
Eden 영역에서 GC가 발생하면 이미 살아남은 객체가 존재하는 Survivor 영역으로 객체가 계속 쌓인다.
하나의 Survivor 영역이 가득 차게 되면 그 중에서 살아남은 객체를 다른 Survivor 영역으로 이동한다. 그리고 가득 찬 Survivor 영역은 아무 데이터도 없는 상태로 된다.
이 과정을 반복하다가 계속해서 살아남아 있는 객체는 Old 영역으로 이동하게 된다.
이 절차를 확인해 보면 알겠지만 Survivor 영역 중 하나는 반드시 비어 있는 상태로 남아 있어야 한다. 만약 두 Survivor 영역에 모두 데이터가 존재하거나, 두 영역 모두 사용량이 0이라면 여러분의 시스템은 정상적인 상황이 아니라고 생각하면 된다.
    
Old 영역에 대한 GC
Old 영역은 기본적으로 데이터가 가득 차면 GC를 실행한다. 
GC 방식에 따라서 처리 절차가 달라지므로, 어떤 GC 방식이 있는지 살펴보면 이해가 쉬울 것이다. GC 방식은 JDK 7을 기준으로 5가지 방식이 있다.
Serial GC
Parallel GC
Parallel Old GC(Parallel Compacting GC)
Concurrent Mark & Sweep GC(이하 CMS)
G1(Garbage First) GC
이 중에서 운영 서버에서 절대 사용하면 안 되는 방식이 Serial GC다. 
Serial GC는 데스크톱의 CPU 코어가 하나만 있을 때 사용하기 위해서 만든 방식이다. Serial GC를 사용하면 애플리케이션의 성능이 많이 떨어진다.

################################################################################
5.6 What is the difference between Serial and Throughput Garbage collector ? 위 참고
5.7 When does an Object becomes eligible for Garbage collection in Java ? 위 참고
5.8 Does Garbage collection occur in permanent generation space in JVM ? 위 참고

################################################################################
################################################################################
6 Exception Handling 14
################################################################################
6.1 What are the two types of Exceptions in Java ? Which are the differences between them ?
예외(Exception)은 일종의 오류로 두 가지로 나눌 수 있다.
① 문법 오류 : 오타와 같이 자바 구문에 어긋난 코드 때문에 발생하고, 컴파일시에 발생하는 오류
② 실행 오류 : 프로그램 실행시 상황에 따라 발생하는 오류
실행 오류에는 프로그램 자체의 구조적인 문제로 인한 논리적 오류와 자바 가상 머신 자체의 문제로 인한 오류 그리고 예외가 있다.
논리 오류는 논리적 모순이 생기지 않도록 코딩하는 수밖에 없으며, 자바 가상 머신 자체의 오류는 프로그래머가 책임질 수 있는 수준의 오류가 아니다.

예외(Exception)은 프로그램 실행 중에 발생할 수 있는 예기치 않은 사건으로 프로그래머의 노력으로 처리할 수 있다.
자바 가상 머신은 프로그램 실행중에 예외가 발생하면 관련된 예외 클래스로부터 예외 객체를 생성하여 프로그램에서 지정된 예외 처리 구문으로 넘긴다. 
프로그램에 지정된 예외 처리 구문은 예외가 발생하면 자바 가상 머신에 의해 호출되고 예외 객체를 자바 가상 머신으로부터 넘겨받아 적절한 처리를 수행한다.

################################################################################
6.2 What is the difference between Exception and Error in java ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
java에서 발생한 문제는 일단 상위스택에게 던져 버린다고 생각하면 됩니다. 
a()에서 b()를 호출했을 때 b() 안에서 문제가 발생하면 일단 위로 던져서 a()에게 그 처리를 위임하는 것이라고 보시면 됩니다. 
a()는 다시 상위로 던집니다. 
그러다가 최종적으로는 jvm에서 이런 일이 발생했다고 찍어줍니다. 

try-catch는 문제가 발생했을 때, 상위로 안 던지고 자기가 처리하겠다는 의미입니다. 
즉, 문제를 상위로 위임시키는 것을 중지시킨다는 의미입니다. 
그리고 메쏘드에 선언된 throws는 상위로 그냥 던지라는 의미입니다. 
이를 잘 조합하면, b()에서 발생한 문제를 a()에서 처리할 수도 있다는 뜻입니다.

Error과 Exception은 전부 Throwable을 상속 받습니다.
 
Error은 비교적 심각한 문제들을 나타냅니다. 
예외처리가 가능하긴 합니다만, 처리를 하려고 해도 처리가 안 되는 경우도 있을 수 있습니다. 
처리를 하지 않아도 컴파일 타임에는 문제가 없습니다. 
즉, 굳이 try-catch로 어딘가에서 감싸지 않는다면, Error을 상속 받는 문제들은 스택을 타고타고 JVM까지 올라갑니다. 

예외 처리가 가능한 Error의 대표적인 예는 StackOverflowError입니다. 
하지만, JVM을 죽일만큼 심각한 에러는 잡아 낼 수 없습니다. 
특히 자바 코드가 아닌 native에서 발생한 문제로 인해 발생한 에러 등은 잡아내지 못하는 경우가 많습니다.

Exception은 RuntimeException과 그 외의 Exception으로 구분됩니다. RuntimeException이란 것은 실제로 존재하는 클래스입니다. 

################################################################################
6.3 What is the difference between throw and throws ?
throw 키워드는 프로그램 내에서 명시 적으로 예외를 발생시키는 데 사용됩니다. 
반대로 throws 절은 메소드에서 처리하지 않는 예외를 나타내는 데 사용됩니다. 
각 메소드는 처리 할 수없는 예외를 명시해야하므로 해당 메소드의 호출자는 발생 가능한 예외를 방지 할 수 있습니다.

throws는 전가이고 throw 는 프로그래머의 판단에 따른 처리이다.

################################################################################
6.4 What is the importance of finally block in exception handling ?
try 블록은 예외가 발생할 가능성이 있는 범위를 지정하는 블록이다. 
try 블록은 최소한 하나의 catch 블록이 있어야 하며, catch 블록은 try 블록 다음에 위치한다.

catch 블록의 매개변수는 예외 객체가 발생했을 때 참조하는 변수명으로 반드시 java.lang.Throwable 클래스의 하위 클래스 타입으로 선언되어야 한다.
지정된 타입의 예외 객체가 발생하면 try 블록의 나머지 문장들은 수행되지 않고, 자바 가상 머신은 발생한 예외 객체를 발생시키며 발생한 예외 객체 타입이 동일한 catch 블록을 수행한다.

finally 블록은 필수 블록은 아니다.
finally 블록이 사용되면 finally 블록의 내용은 예외 발생 유무나 예외 catch 유무와 상관 없이 무조건 수행된다. 
따라서, 데이터베이스나 파일을 사용한 후 닫는 기능과 같이 항상 수행해야 할 필요가 있는 경우에 사용한다.

################################################################################
6.5 What will happen to the Exception object after exception handling ?
Exception개체는 다음 가비지 컬렉션에서 수집대상이 된다.

################################################################################
6.6 How does finally block differ from finalize() method ?
finally 블록은 예외가 발생했는지 여부에 관계없이 실행되며 응용 프로그램이 보유한 리소스를 해제하는 데 사용됩니다. 
Finalize는 객체가 가비지 수집되기 바로 전에 Java Virtual Machine (JVM)에 의해 호출되는 Object 클래스의 보호 된 메서드입니다.

################################################################################
################################################################################
9 JDBC
################################################################################
9.1 What is JDBC ?
JDBC(Java Database Connectivity)는 자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API이다. 
JDBC는 데이터베이스에서 자료를 쿼리하거나 업데이트하는 방법을 제공한다.
JDBC 클래스는 자바 패키지 java.sql과 javax.sql에 포함되어 있다.

################################################################################
9.2 Explain the role of Driver in JDBC.
JDBC 드라이버는, JDBC API가 제공하는 추상 클래스의 벤더 고유의 구현을 제공합니다. 
각 드라이버는 java.sql 패키지의 다음 클래스의 구현을 제공해야합니다.
Connection, Statement, PreparedStatement, CallableStatement, ResultSet...

################################################################################
9.3 What is the purpose Class.forName method ?
데이터베이스에 대한 연결을 설정할 드라이버를로드하는 데 사용됩니다.

################################################################################
9.4 What is the advantage of PreparedStatement over Statement ?
PreparedStatement는 사전 컴파일되어 있으므로 성능이 훨씬 좋습니다 . 
또한 PreparedStatement 객체는 쿼리에 대해 다른 입력 값으로 재사용 할 수 있습니다.

################################################################################
9.5 What is the use of CallableStatement ? Name the method, which is used to prepare a CallableStatement.
CallableStatement는 저장 프로 시저를 실행하는 데 사용됩니다. 
저장 프로시 저는 데이터베이스에 저장되고 제공됩니다. 
저장 프로시 저는 사용자로부터 입력 값을 취할 수 있으며 결과를 반환 할 수 있습니다. 
저장 프로 시저의 사용은 보안 및 모듈성을 제공하므로 매우 권장됩니다. 
메서드 CallableStatement는 다음과 같습니다.
CallableStament.prepareCall();

################################################################################
9.6 What does Connection pooling mean ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
Java Programming에서 Database로 Connection을 맺는 일은 매우 느리며 자원을 많이 소모하는 작업이다. 
그러므로 불특정 다수의 사용자들이 동시에 Database의 Connection을 요구한다면 최악의 경우 server가 down되기도 한다. 
이것을 해결하기 위해 Connection Pool을 이용한다.
 
Connection Pool은 Database와의 연결을 효율적으로 관리하는 역할을 한다.
사전에 일정량의 Connection 객체를 만들어 공유된 장소에 모아둔다. 
시간이 걸리는 Connection 객체 생성을 사전에 해 둠으로써 속도향상을 기대할 수 있다. 
Java Programming에서 사용이 끝난 Connection객체를 다시 공유된 장소에 넣어둔다.
 
예전에 이 같은 Connection Pool을 직접 개발하곤 했으나 최근에는 JDBC Driver내에 자체적으로 내장되어 있는 경우가 많다.

################################################################################
################################################################################
10 Remote Method Invocation (RMI)
################################################################################
10.1 What is RMI ?
기존의 자바 소켓(Socket) 으로 대부분의 통신 프로그래밍이 가능했으나 
분산되어 있는 객체간의 메시지 교환을 위해서는 프로그래머가 일일이 응용레벨 프로토콜을 직접 설계 해야 하며 
이는 복잡하고 애러를 발생시키는 주된 요인이 되기도 한다. 
이러한 소겟 프로그래밍을 대체 할수 있는 것이 원격메소드호출 (Remote Mothod Invocation)이며, 
RMI 는 분산된 객체들을 local 객체처럼 사용이 가능하다.

RMI 의 개발 목적.

* 안정된 원격 호출의 제공.
* 서버에서 애플랫으로의 콜백 제공.
* 분산모델을 자바환경으로의 통합.
* 분산 객체와 비분산 객체의 명확한 구분.
* 안정된 분산 애플리케이션을 간편하게 만들수 있는 환경제공.
* 자바 런타임환경에의해 제공되는 안전성 유지.

나머지 생략...

################################################################################
################################################################################
11 Servlets
################################################################################
11.1 What is a Servlet ?
자바 서블릿(Java Servlet)은 자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 혹은 그 사양을 말하며, 흔히 "서블릿"이라 불린다. 
자바 서블릿은 웹 서버의 성능을 향상하기 위해 사용되는 자바 클래스의 일종이다. 
서블릿은 JSP와 비슷한 점이 있지만, JSP가 HTML 문서 안에 Java 코드를 포함하고 있는 반면, 서블릿은 자바 코드 안에 HTML을 포함하고 있다는 차이점이 있다.

자바 서블릿은 자바 EE 사양의 일부분으로, 주로 이 기능을 이용하여 쇼핑몰이나 온라인 뱅킹 등의 다양한 웹 시스템이 구현되고 있다.
비슷한 기술로는 펄 등을 이용한 CGI, PHP를 아파치 웹 서버 프로세스에서 동작하게 하는 mod_php, 마이크로소프트사의 IIS에서 동작하는 ASP 등이 있다. 
CGI는 요청이 있을 때마다 새로운 프로세스가 생성되어 응답하는 데 비해, 자바 서블릿은 외부 요청마다 프로세스보다 가벼운 스레드로써 응답하므로 보다 가볍다. 
또한, 자바 서블릿은 자바로 구현되므로 다양한 플랫폼에서 동작한다.

################################################################################
11.2 Explain the architechure of a Servlet.

참고 : http://wiki.gurubee.net/pages/viewpage.action?pageId=26740202
1.1 Servlet 이란
Servlet은 웹에서 JAVA 프로그래밍을 구현하기 위해 탄생 함.
JAVA 로 구현된 CGI(Common Gateway Interface) 라고들 흔히 말함
HTTP protocol 서비스를 지원하는 javax.servlet.http.HttpServlet 클래스를 상속하여 개발하며, Servlet은 Container에 의해서 실행되고, 관리된다.
HTML 변경시 Servlet을 재컴파일 해야 하는 단점이 있다.

1.2 Servlet Container란
HTTP 요청을 받아서 Servlet을 실행시키고, 그 결과를 사용자 브라우저에게 전달해주는 기능을 제공하는 컴포넌트 이다.
Servlet을 실행하고 생명주기를 관리하는 역할을 한다.
Servlet과 웹 서버(Apache, nginx..)가 서버 통신 할 수 있는 방법을 제공한다.
멀티 스레딩을 지원하여 클라이언트의 다중 요청을 알아서 처리해준다.
대표적인 Conatainer에는 Tomcat, jetty, jboss 등이 있다.

1.3 Servlet 동작과정
① 사용자가 URL을 클릭하면 HTTP Request를 Servlet Container에 보낸다.
② Servlet Container는 HttpServletRequest, HttpServletResponse 두 객체를 생성한다.
③ 사용자가 요청한 URL을 분석하여 어느 서블릿에 대한 요청인지 찾는다. (DD를 참조하여 분석)
④ 컨테이너는 서블릿 service() 메소드를 호출하며, POST, GET여부에 따라 doGet() 또는 doPost()가 호출된다.
⑤ doGet() or doPost() 메소드는 동적인 페이지를 생성한 후 HttpServletResponse객체에 응답을 보낸다.
⑥ 응답이 완료되면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킨다.

DD (배포서술자, Deployment Descriptor) = web.xml
Servlet, Error Page, Listener, Fillter, 보안 설정등 Web Application의 설정 파일이다.
URL과 실제 서블릿의 매핑 정보도 담고 있다.
하나의 웹 어플리케이션에 하나만 존재한다.
보통 Web Document Root 디렉토리에 WEB-INF 폴더 아래 web.xml 파일로 존재한다.

################################################################################
11.3 What is the difference between an Applet and a Servlet ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
애플릿(Applet) 
패널(Panel)을 상속하는 클래스로 웹 브라우저에 담겨서 실행되는 작은 자바 응용 프로그램
예전에 HTML의 정적인 면을 보완해주는 도구로 인기를 끔 -> 플래시로 인해 인기 줄어듬
 
서블릿(Servlet)
웹 서버 상에서 실행되는 자바의 클래스 파일
1. 자바의 모든 API를 그대로 사용가능
2. 강력한 객체지향성
3. 반드시 javax.servlet.Servlet 인터페이스를 구현(implements)해서 작성해야함.
4. 입력과 출력을 HTTP프로토콜의 Request와 Response의 형태로 다룸
 
클라이언트가 요청을 보내면, 웹서버는 서블릿클래스 파일을 실행하고 서블릿 클래스는 요청을 처리해 결과를 HTML로 만들어서 웹서버를 통해 클라이언트에게 전송 (Server Side Applet)

################################################################################
11.4 What is the difference between GenericServlet and HttpServlet ? . . . . . . . . . . . . . . . . . . . . . . . . . . 25
<인터페이스>Servlet <- GenericServlet <- HttpServlet <- MyServlet
GenericServlet 클래스
(javax.servlet.GenericServlet)
GenericServlet은 추상 클래스입니다. 
필요한 대부분의 서블릿 메소드를 구현했으며, 여기에는 Servlet 인터페이스에 정의된 것도 있습니다. 
이 클래스를 상속받아 클래스를 생성할 일은 거의 없을 겁니다. 
하지만 대부분 서블릿의 '서블릿 행위'라고 하는 것들이 바로 이 클래스로부터 나왔다는 것은 기억하세요.

HttpServlet 클래스
(javax.servlet.http.HttpServlet)
HttpServlet도 추상 클래스입니다. 
HttpServlet은 서블릿의 HTTP적인 측면을 반영하기 위하여 service() 메소드를 재정의하는 것입니다. 
즉 service() 메소드는 오로지 HTTP Request와 Response만 받아들이고 다른 어떤 서블릿 Request와 Response는 받지 않는다는 말입니다.

################################################################################
11.5 Explain the life cycle of a Servlet.
init()->service()->destroy()
모든 클라이언트의 요청에서 서블릿 엔진은 서블릿을 초기화하고 초기화 메소드를 호출하여 서블릿을 초기화합니다. 
그런 다음 Servlet 객체는 각 요청에 대해 개별적으로 service 메소드를 호출하여 해당 클라이언트에서 오는 모든 후속 요청을 처리합니다. 
마지막으로 서블릿은 서버의 destroy 메소드를 호출하여 제거됩니다.

① 사용자가 URL을 클릭하면 HTTP Request를 Servlet Container에 보낸다.
② Servlet Container는 HttpServletRequest, HttpServletResponse 두 객체를 생성한다.
③ 사용자가 요청한 URL을 분석하여 어느 서블릿에 대한 요청인지 찾는다. (DD를 참조하여 분석)
④ 컨테이너는 서블릿 service() 메소드를 호출하며, POST, GET여부에 따라 doGet() 또는 doPost()가 호출된다.
⑤ doGet() or doPost() 메소드는 동적인 페이지를 생성한 후 HttpServletResponse객체에 응답을 보낸다.
⑥ 응답이 완료되면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킨다.

################################################################################
11.6 What is the difference between doGet() and doPost() ?
doGET: GET 메소드는 요청의 URL에 이름 - 값 쌍을 추가합니다. 
    따라서 문자 수와 클라이언트의 요청에 사용할 수있는 값의 수에는 제한이 있습니다. 
    또한 요청 값이 표시되므로 민감한 정보가 전달되지 않아야합니다. 
doPOST: POST 메서드는 요청의 값을 본문 내에 전송하여 GET 요청에 의해 부과 된 제한을 극복합니다. 
    또한 전송할 값의 수에는 제한이 없습니다. 
    마지막으로 POST 요청을 통해 전달 된 중요한 정보는 외부 클라이언트에 표시되지 않습니다.

1) GET 방식
- 사용 방식 : <a href="list.jsp?pageNo=2">[2]</a>
- GET 방식으로 요청이 전송되는 경우 :
1. 브라우저 주소 표시중에 주소를 직접 입력해서 요청하는 경우
2. Html의 a(앵커) 태그를 사용해서 링크를 걸어서 요청하는 경우
3. Html 폼 태그에서 method 속성을 GET으로 지정하여 요청하는 경우
<form action="" name="" method="GET">
- 간단한 파라미터를 필요하고 보안상 노출되어도 상관없을 경우
 
2) POST 방식 
- 특정 페이지로 많은 양의 파라미터를 전송하거나 보안상 노출되어서는 안되는 파라미터를 전송할 경우
- 회원 가입, 글쓰기, 자료실 업로드등 처리에 사용
- 사용 방식 : <form action="" name="" method="POST">

################################################################################
11.7 What is meant by a Web Application ?
소프트웨어 공학적 관점에서 웹 애플리케이션(web application) 또는 웹 앱은 인터넷이나 인트라넷을 통해 웹 브라우저에서 이용할 수 있는 응용 소프트웨어를 말한다.
웹 애플리케이션은 클라이언트로서 웹 브라우저를 사용하는 사람이 많기 때문에 인기를 누리고 있다. 
수천만 대의 PC에 굳이 소프트웨어를 배포해서 설치하지 않아도 웹 애플리케이션을 유지 관리할 수 있다는 점이 장점 중의 하나이다. 
웹 애플리케이션은 웹 메일, 온라인 전자상거래 및 경매, 위키, 인터넷 게시판, 블로그 및 MMORPG 게임 등 다양한 기능을 구현할 수 있다.
 
웹 응용 프로그램에는 프레젠테이션 지향과 서비스 지향이라는 두 가지 유형이 있습니다. 
프레젠테이션 지향 웹 응용 프로그램은 요청에 대한 응답으로 다양한 유형의 마크 업 언어와 동적 콘텐츠가 포함 된 대화 형 웹 페이지를 생성합니다. 
한편, 서비스 지향 웹 응용 프로그램은 웹 서비스의 끝점을 구현합니다. 
일반적으로 웹 응용 프로그램은 서버 URL 네임 스페이스의 특정 하위 집합에 설치된 서블릿 모음으로 볼 수 있습니다.

################################################################################
11.8 What is a Server Side Include (SSI) ?
SSI는 서버가 HTML 파일을 사용자에게 보내기 직전에 포함할 수 있는 변수 값이다 (예를 들면, "Last modified" 라는 구절 다음에 날짜를 나타내는 등). 
웹페이지를 만들 때, HTML 파일 내에 다음과 같은 문장을 삽입할 수 있는데,
<!--#echo var="LAST_MODIFIED"-->
그러면, 서버는 그 파일이 최종 수정된 날짜를 읽은 다음, HTML 파일을 사용자에게 보내기 직전에 그 값을 삽입해 준다.
LAST_MODIFIED는 운영체계가 추적할 수 있고, 또한, 서버 프로그램이 이용할 수 있는 여러 가지 환경변수들 중의 하나이다. 
서버 관리자는 시스템을 설정할 때 이러한 환경변수들을 사용 가능하게 할 수 있다.
위의 예에서 "echo"라는 문장과 같은 SSI 문장들을 포함하고 있는 웹파일은 대개 관리자에 의해 ".shtml"이라는 파일이름 확장자를 붙이도록 정의된다. 
SSI를 CGI 응용의 제한된 한 형태라고 생각할 수도 있지만, 그러나 실제로, CGI는 사용되지 않는다. 
서버는 단지 CGI 환경변수들을 위해 SSI 파일을 찾은 다음, 이 파일 내에 "include"라는 문장이 들어가 있는 곳에 가변적인 정보를 삽입한다.

################################################################################
11.9 What is Servlet Chaining ?
서블릿 체인은 한 서블릿의 출력을 두 번째 서블릿으로 보내는 방법입니다. 
두 번째 서블릿의 출력은 세 번째 서블릿에 보내질 수 있습니다. 
체인의 마지막 서블릿은 클라이언트에 응답을 보내는 역할을합니다.

필터란 웹기반의 리소스 위에다가 별도의 기능을 얹을 수 있게 하는 장치이다.
필터를 사용하면 요청과 응답을 가로채 새로운 동작을 수행할 수 있다.

서블릿 체이닝 은 여러 개의 서블릿을 하나의 요청에 순차적으로 적용해서 응답정보를 한번씩 만들어 낼 수 있게 하는 것이다.
필터의 동작은 요청이 처리되는 동안 한 필터가 그 다음의 필터로 제어권을 넘겨주고, 원하는 리소스까지 도달하게되면 일단 멈추는 식으로 진행된다. 
원하는 리소스를 나타내는 응답이 만들어진 후에는 다시 필터가 순차적으로 작동하면서 추가 처리를 수행하는데 이는 처음과는 반대순서로 작동한다.
이런 과정이 진행되는 도중에 어느때라도 필터는 다른 리소스로 제어권을 넘겨줄 수 있다.

1. 각 서블릿의 출력이 다른 서블릿의 입력으로 
2. 효과적인 실시간 체인의 구현 
3. 기능 
  페이지의 외양의 변경 
  Content의 중요 부분들을  특이하게 표시 
4. 장점 
  쉬운 실행취소 
  동적인 Content 생산가능 
  유지보수 용이 

################################################################################
11.10How do you find out what client machine is making a request to your servlet ?
ServletRequest 클래스에는 클라이언트 시스템의 IP 주소 또는 호스트 이름을 찾는 함수가 있습니다. 
getRemoteAddr ()은 클라이언트 시스템의 IP 주소를 가져오고 
getRemoteHost ()는 클라이언트 시스템의 호스트 이름을 가져옵니다.

################################################################################
11.11What is the structure of the HTTP response ?
상태 코드 : 응답 상태를 나타냅니다. 
            요청이 성공적으로 완료되었는지 확인하는 데 사용할 수 있습니다. 
            요청이 실패한 경우 상태 코드를 사용하여 오류의 원인을 찾을 수 있습니다. 
            서블릿이 상태 코드를 반환하지 않으면 기본적으로 성공 상태 코드 인 HttpServletResponse.SC_OK가 반환됩니다.
HTTP 헤더 : 응답에 대한 자세한 정보가 들어 있습니다. 
            예를 들어, 헤더는 날짜/시간 또는 엔터티를 사용자에게 안전하게 전송하는 데 사용되는 인코딩 형식을 지정할 수 있습니다.
본문 : 응답 내용이 들어 있습니다. 
        본문은 HTML 코드, 이미지 등을 포함 할 수 있습니다.

################################################################################
11.12What is a cookie ? What is the difference between session and cookie ?
쿠키란?
쿠키란 서버측에서 클라이언트측에 상태 정보를 저장하고 추출할 수 있는 메커니즘
클라이언트의 매 요청마다 웹 브라우저로부터 서버에게 전송되는 정보패킷의 일종
HTTP에서 클라이언트의 상태 정보를 클라이언트의 하드 디스크에 저장하였다가 필요 시 정보를 참조하거나 재사용할 수 있음.

사용 예
방문했던 사이트에 다시 방문 하였을 때 아이디와 비밀번호 자동 입력
팝업에서 “오늘 이 창을 다시 보지 않음” 체크

쿠키의 제약조건
클라이언트에 총 300개까지 쿠키를 저장할 수 있다
하나의 도메인 당 20개의 값만을 가질 수 있다
하나의 쿠키 값은 4096Byte까지 저장 가능하다
하나의 도메인에서 설정한 쿠키값이 20개를 초과하면 가장 적게 사용된 쿠키부터 지워짐. 
또한 쿠키는 기존에 설정한 값이 있는 곳에 값을 저장하거나 배열형태의 쿠키에 단일 값을 저장하려고 할 때 아무런 경고 없이 덮어쓰기 때문에 주의를 해야 한다.
 
세션이란?
세션이란 클라이언트와 웹서버 간에 네트워크 연결이 지속적으로 유지되고 있는 상태를 말함
클라이언트가 웹서버에 요청하여 처음 접속하면 JSP(혹은ASP)엔진은 요청한 클라이언트에 대하여 유일한 ID를 부여하게 되는데, 이 ID를 세션이라 부른다
세션 ID를 임시로 저장하여 페이지 이동 시 이용하거나, 클라이언트가 재 접속 했을 때 클라이언트를 구분할 수 있는 유일한 수단이 된다

세션의 장점
각각의 클라이언트마다 고유의 ID 부여
세션 객체마다 저장해 둔 데이터를 이용하여 서로 다른 클라이언트의 요구에 맞게 서비스 제공
클라이언트 자신만의 고유한 페이지를 열어놓아서 생길 수 있는 보안상의 문제 해결 용이

쿠키와 세션의 차이점
쿠키(cookie)와 세션(session)은 기능상 비슷한 역할을 하고, 동작원리도 비슷하다. 
왜냐하면, 일반적인 세션은 쿠키를 바탕으로 동작하기 때문이다. 
그러나 가장 중요한 차이점은 저장되는 곳이 다르다는 것이다. 
쿠키는 클라이언트에 저장되고, 세션은 서버에 저장된다. 
쿠키의 경우에는 서버의 자원을 전혀 사용하지 않지만, 세션의 경우에는 서버에 저장되기 때문에 서버의 자원을 사용할 수가 있다. 
쿠키와 세션의 만료 되는 기간도 다르다.

################################################################################
11.13Which protocol will be used by browser and servlet to communicate ?
브라우저는 HTTP 프로토콜을 사용하여 서블릿과 통신합니다.

################################################################################
11.14What is HTTP Tunneling ?
HTTP 터널링은 다양한 네트워크 프로토콜을 사용하여 수행되는 통신이 HTTP 또는 HTTPS 프로토콜을 사용하여 캡슐화되는 기술입니다. 
따라서 HTTP 프로토콜은 터널링되는 네트워크 프로토콜이 통신하는 데 사용하는 채널의 래퍼 역할을합니다. 
HTTP 요청과 같은 다른 프로토콜 요청의 마스킹은 HTTP 터널링입니다.

인터넷을 사적이며 안전한 네트워크의 일부로서 사용하는 것으로서, 한네트워크에서 다른 네트워크의 접속을 거쳐 데이터를 보낼 수 있도록 하는 기술을 말한다.
터널링은 두번째 네트워크에 의해 운송되는 패킷들 내에 네트워크 프로토콜을 켑슐화함으로써 운영된다.
예를 들어, 마이크로소프트 PPTP기술은 조직이 가상사설망을 거쳐 데이터를 전송하는데, 인터넷을 사용할 수 있게 해준다. 
그것은 자신들만의 고유한 네트워크 프로토콜을 인터넷에 의해 전송되는  TCP/IP 패킷내에 삽입함으로써 이루어진다.
여기서 "터널"이란 어떤 회사의 메시지나 파일이 인터넷을 통해 이동할 수 있는 특별한 통로를 말한다. 
여기에 사용되는 프로토콜을 PPTP 라고 부르는데 이것은 인터넷상의 "터널"을 통해 가상사설망을 구축할 수 있도록 하기 위해 제안되었다. 
이것은 회사들이 광역통신망 구축을 위해 더이상 전용회선을 필요로 하지 않는다는 것과, 공중네트워크를 안전하게 이용할 수 있다는 것을 의미한다.

################################################################################
11.15What’s the difference between sendRedirect and forward methods ?
forward는 웹어플리케이션 내부에서만 이동할 수 있습니다.
반대로 sendRedirect는 외부 내부 상관없이 이동할 수 있습니다. 즉 다른 도메인의 주소로도 이동이 가능합니다.

forward는 request, response객체를 모두 다 전달하기 때문에 이동된 페이지(또는 서블릿)에서도 request와 response객체를 이용해서 파리미터를 받아서 처리할 수 있습니다.
sendRedirect는 이게 안 되죠.
access_log 파일에 보면 forward의 기록은 남지 않습니다.
sendRedirect는 기록이 남지요.

################################################################################
11.16What is URL Encoding and URL Decoding ?
URL인코딩이란, URL내에 곧바로 입력 할 수 없는 문자는 URL 인코딩을 해야 한다.
URL 뒤에 데이터를 덧붙이고자 할때 스트링을 URL에 맞게 인코딩을 해야하는데 아래와 같이 하면 된다.
String encodeResult = URLEncoder.encode(String encodingString, String charsetName);

그냥 URLEncoder.encode(String s); 는 deprecated 되었으니까 사용하지 말고 위의 함수를 사용하자.
charsetName에는 "UTF-8"과 같은 캐릭터 인코딩 셋을 넣으면 된다. 

반대로 디코딩하는 것은 아래와 같이 하면 된다.
String decodeResult = URLDecoder.decode(String decodingString, String charsetName);

URL을 Encoding해야 되는 이유는 크게 2가지다.
1. RFC3986에 따르면 URL은 ASCII Character-set으로만 구성되어야 하기 때문에 한글을 포함한 대부분의 외국어나 ASCII에 정의되지 않은 특수문자의 경우 URL에 포함될 수 없기 때문에.
2. URL 내에서 의미를 갖고 있는 문자(%, ?, #)나 URL에 올 수 없는 문자 (Space) 혹은 System에서 해석이 될 수 있는 문자(<, >)를 치환하여 야기될 수 있는 문제점을 예방하기 위해.

################################################################################
################################################################################
12 JSP
################################################################################
12.1 What is a JSP Page ?
자바서버 페이지(JavaServer Pages, JSP)는 HTML내에 자바 코드를 삽입하여 웹 서버에서 동적으로 웹 페이지를 생성하여 웹 브라우저에 돌려주는 언어이다.

JSP (Java Server Page)는 정적 데이터와 JSP 요소의 두 가지 유형의 텍스트를 포함하는 텍스트 문서입니다. 
정적 데이터는 HTML 또는 XML과 같은 텍스트 기반 형식으로 표현 될 수 있습니다. 
JSP는 정적 컨텐츠와 동적으로 생성 된 컨텐츠를 혼합하는 기술입니다.

################################################################################
12.2 How are the JSP requests handled ? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
- 변환(translation) 단계 : JSP → 자바 코드
- 컴파일(compile) 단계 : 자바 코드  → 서블릿 클래스
- JSP에 해당하는 서블릿이 존재하지 않을 경우, 변환 단계와 컴파일 단계를 거쳐서 클라이언트의 요청을 처리한다.
- JSP에 해당하는 서블릿이 존재하는 경우, 곧바로 서블릿을 사용하여 클라이언트의 요청을 처리한다.

################################################################################
12.3 What are the advantages of JSP ?
JSP, ASP, PHP 차이점 
1. OS 측면
JSP : 자바의 특징이 포함되어 있는 스크립트 언어이므로 자바처럼 플랫폼에 독립적
ASP : NT or 2000 등의 MS 환경
PHP : 리눅스, 유닉스, MS 계열 OS

2. DB 측면
JSP : 오라클, MS-Sql, My-Sql 등 폭넓은 DB에서 사용 가능
ASP : 앞에서 언급한 OS와 같이 MS 계열 DB인 MS-Sql로 작성하는 것이 가장 보편적
PHP : 많은 DB를 지원하지만 주로 보편적으로 My_Sql을 사용
 
JSP, ASP, PHP 장단점 
JSP(Java Server Page) 
자바를 기반으로 한 기술이므로 자바가 가지고 잇는 장점을 그대로 가지고 있다. 
자바의 큰 장점인 특정 하드웨어 플랫폼이나 운영체제 혹은 서버 소프트웨어에 의존적이지 않다는 것이 JSP에도 적용이 된다. 
또한 사용자의 요청이 있을 때 각 요청마다 하나의 프로세스를 생산하지 않기 때문에 서버가 갖게되는 부하를 많이 줄일 수가 있으며 
객체 개념과 JavaBean을 사용해 재사용이 가능하다는 장점도 있다.
 
ASP(Active Server Page)
단점은 윈도우 시스템에서 실행되는 IIS(Internet Information Server)에서만 사용이 가능하다. 
JSP와 ASP 둘 다 동적 웹페이지 생성을 위해 태그와 스크립트를 조합하지만 관리적인 측면에서는 ASP가 어렵다는 단점이 있다.
 
PHP(Professional HTML Preprocessor)
ASP나 JSP와 유사한 오픈 소스 스크립트 시스템이다. 
PHP는 자신만의 스크립팅 언어를 정의하는데 Perl과 유사하다. 
가장 큰 장점은 프로그램이 간결하면서 쉽게 DB와 연동을 하는 것이다. 
그러나 PHP가 모든 필요한 것을 PHP가 해결해 주어야 한다는 단점이 있다. 
즉 PHP가 제공하지 않는 방법으로는 해결 방법을 찾을 수 없다는 말이다. 
PHP는 성능 향상을 위해 구문을 최소화 했기 때문에 객체 지향이나 코드의 재사용 등의 장점을 누릴 수 없다.

셋 다 프로그래밍은 HTML의 정적인 특성과 CGI의 기술의 단점인 속도 문제를 해결하기위해 나타난 스크립트 형식의 언어들 이다. 
게시판이나 회원 관리 등의 데이터베이스와 연동해서 쓸수는 있지만 채팅 프로그램같은 스크립트 형식의 언어로서 한계인 실시간 처리 문제는 아직 과제로 남아 있다.

################################################################################
12.4 What are Directives ? What are the different types of Directives available in JSP ?
JSP에서 지시자는 컨테이너가 페이지를 자바코드로 변환 할 때 특별한 지시를 내릴 수 있도록 고안된 것들을 말한다.
지시자에는 page, include, taglib가 있다.

지시어는 JSP페이지 내에서 JSP컨테이너에게 페이지를 어떻게 처리할 것인가에 대한 정보를 알려주는데 사용된다.
지시문은 페이지가 서블릿으로 컴파일 될 때 JSP 엔진에서 처리하는 명령어입니다. 
지시문은 페이지 수준 명령어를 설정하고, 외부 파일에서 데이터를 삽입하고, 사용자 정의 태그 라이브러리를 지정하는 데 사용됩니다. 
정의 < %@ and % >
include : 파일을 포함시키는 데 사용되며 파일의 내용을 현재 페이지와 병합합니다.
page : 오류 페이지 및 버퍼와 같은 JSP 페이지의 특정 속성을 정의하는 데 사용됩니다.
taglib: 페이지에서 사용되는 사용자 정의 태그 라이브러리를 선언하는 데 사용됩니다.

################################################################################
12.5 What are JSP actions ?
JSP 동작은 XML 구문의 구문을 사용하여 서블릿 엔진의 동작을 제어합니다. 
JSP 페이지가 요청되면 JSP 액션이 실행됩니다. 
파일에 동적으로 삽입하거나, JavaBeans 구성 요소를 다시 사용하거나, 사용자를 다른 페이지로 전달하거나, Java 플러그인 용 HTML을 생성 할 수 있습니다. 
사용 가능한 동작 중 일부는 다음과 같습니다.
jsp:include - JSP 페이지가 요청 될 때 파일을 포함합니다.
jsp:useBean - JavaBean을 찾거나 인스턴스화합니다.
jsp:setProperty - JavaBean의 속성을 설정합니다.
jsp:getProperty - JavaBean의 속성을 가져옵니다.
jsp:forward - 요청자를 새 페이지로 전달합니다.
jsp:plugin - 브라우저 관련 코드를 생성합니다.

################################################################################
12.6 What are Scriptlets ?
■ JSP 스크립틀릿(Scriptlet) 
<%  %>
HTML 코드로 된 부분은 일반 HTML 파일처럼 그대로 사용하고 자바 코드로 이루어진 로직 부분은 <% .. %> 로 표현되는 스크립틀릿 태그를 사용하여 구분함


################################################################################
12.7 What are Decalarations ?
■ JSP 선언문(Declarations) 
<%! %>
선언문은 jsp 페이지에서 자바 코드에서 말하는 멤버 변수와 메소드를 선언하기 위해 사용됨

################################################################################
12.8 What are Expressions ?
■ JSP 표현식(Expression) 
<%= %>
선언문 또는 스크립트릿 태그에서 선언된 변수나 메소드의 리턴값을 출력하기 위해 사용됨
스크립틀릿과는 달리 세미콜론(;)을 사용해서는 안됨

################################################################################
12.9 What is meant by implicit objects and what are they ?
JSP Implicit Objects는 사전 정의 된 변수라고도합니다.
다음 객체는 JSP 페이지에서 암시 적으로 간주됩니다.
application, page, request, response, session, exception, out, config, pageContext

################################################################################
################################################################################

자바 컬렉션 프레임워크 40개
http://starplatina.tistory.com/entry/%EC%9E%90%EB%B0%94-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EC%9D%B8%ED%84%B0%EB%B7%B0-%EC%A7%88%EB%AC%B8-40%EA%B0%9C

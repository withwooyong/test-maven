6시간 28분 45초
1. 알고리즘과 입/출력  
https://www.acmicpc.net/problem/2557 Hello World
https://www.acmicpc.net/problem/1000 A+B
https://www.acmicpc.net/problem/2558 A+B - 2
https://www.acmicpc.net/problem/10950 A+B - 3
https://www.acmicpc.net/problem/10951 A+B - 4
https://www.acmicpc.net/problem/10952 A+B - 5
https://www.acmicpc.net/problem/10953 A+B - 6
https://www.acmicpc.net/problem/11021 A+B - 7
https://www.acmicpc.net/problem/11022 A+B - 8
https://www.acmicpc.net/problem/11718 그대로 출력하기
https://www.acmicpc.net/problem/11719 그대로 출력하기 2
https://www.acmicpc.net/problem/11720 숫자의 합
https://www.acmicpc.net/problem/11721 열 개씩 끊어 출력하기

2. 자료구조 1  
https://www.acmicpc.net/problem/10828 스택
https://www.acmicpc.net/problem/9012 괄호
https://www.acmicpc.net/problem/10799 쇠막대기
https://www.acmicpc.net/problem/1406 에디터
https://www.acmicpc.net/problem/10845 큐
https://www.acmicpc.net/problem/1158 조세퍼스 문제
https://www.acmicpc.net/problem/10866 덱
https://www.acmicpc.net/problem/10808 알파벳 개수
https://www.acmicpc.net/problem/10809 알파벳 찾기
https://www.acmicpc.net/problem/10820 문자열 분석
https://www.acmicpc.net/problem/2743 단어 길이 재기
https://www.acmicpc.net/problem/11655 ROT13
https://www.acmicpc.net/problem/10824 네 수
https://www.acmicpc.net/problem/11656 접미사 배열
 
3. 다이나믹 프로그래밍 1  
https://www.acmicpc.net/problem/1463 1로 만들기
https://www.acmicpc.net/problem/11726 2×n 타일링 
https://www.acmicpc.net/problem/11727 2×n 타일링 2
https://www.acmicpc.net/problem/9095 1, 2, 3 더하기
https://www.acmicpc.net/problem/11052 붕어빵 판매하기
https://www.acmicpc.net/problem/10844 쉬운 계단 수
https://www.acmicpc.net/problem/11057 오르막 수
https://www.acmicpc.net/problem/2193 이친수
https://www.acmicpc.net/problem/9465 스티커
https://www.acmicpc.net/problem/2156 포도주 시식
https://www.acmicpc.net/problem/11053 가장 긴 증가하는 부분 수열
https://www.acmicpc.net/problem/11055 가장 큰 증가 부분 수열
https://www.acmicpc.net/problem/11722 가장 긴 감소하는 부분 수열
https://www.acmicpc.net/problem/11054 가장 긴 바이토닉 부분 수열
https://www.acmicpc.net/problem/1912 연속합
https://www.acmicpc.net/problem/2579 계단 오르기
https://www.acmicpc.net/problem/1699 제곱수의 합
https://www.acmicpc.net/problem/2133 타일 채우기(3×N 크기의 벽을 2×1, 1×2 크기의 타일로 채우는 경우의 수)
https://www.acmicpc.net/problem/9461 파도반 수열
https://www.acmicpc.net/problem/2225 합분해
https://www.acmicpc.net/problem/2011 암호코드
 
4. 수학 1 
https://www.acmicpc.net/problem/10430 나머지
https://www.acmicpc.net/problem/2609 최대공약수와 최소공배수
https://www.acmicpc.net/problem/1934 최소공배수
https://www.acmicpc.net/problem/9613 GCD 합
https://www.acmicpc.net/problem/11005 진법 변환 2
https://www.acmicpc.net/problem/2745 진법 변환
https://www.acmicpc.net/problem/1373 2진수 8진수
https://www.acmicpc.net/problem/1212 8진수 2진수
https://www.acmicpc.net/problem/2089 -2진수
https://www.acmicpc.net/problem/11576 Base Conversion
https://www.acmicpc.net/problem/1978 소수 찾기
https://www.acmicpc.net/problem/1929 소수 구하기
https://www.acmicpc.net/problem/6588 골드바흐의 추측
https://www.acmicpc.net/problem/11653 소인수분해
https://www.acmicpc.net/problem/10872 팩토리얼
https://www.acmicpc.net/problem/1676 팩토리얼 0의 개수
https://www.acmicpc.net/problem/2004 조합 0의 개수
 
5. 정렬  
https://www.acmicpc.net/problem/2751 수 정렬하기 2
https://www.acmicpc.net/problem/11650 좌표 정렬하기
https://www.acmicpc.net/problem/11651 좌표 정렬하기 2
https://www.acmicpc.net/problem/10814 나이순 정렬
https://www.acmicpc.net/problem/10825 국영수
https://www.acmicpc.net/problem/10989 수 정렬하기 3
https://www.acmicpc.net/problem/11652 카드
https://www.acmicpc.net/problem/11004 K번째 수
https://www.acmicpc.net/problem/1377 버블 소트
 
6. 그래프 1  
https://www.acmicpc.net/problem/1260 DFS와 BFS
https://www.acmicpc.net/problem/11724 연결 요소의 개수
https://www.acmicpc.net/problem/1707 이분 그래프
https://www.acmicpc.net/problem/10451 순열 사이클
https://www.acmicpc.net/problem/2331 반복수열
https://www.acmicpc.net/problem/9466 텀 프로젝트
https://www.acmicpc.net/problem/2667 단지번호붙이기
https://www.acmicpc.net/problem/4963 섬의 개수
https://www.acmicpc.net/problem/2178 미로 탐색
https://www.acmicpc.net/problem/7576 토마토
https://www.acmicpc.net/problem/2146 다리 만들기
 
7. 트리 1 
https://www.acmicpc.net/problem/1991 트리 순회
https://www.acmicpc.net/problem/11725 트리의 부모 찾기
https://www.acmicpc.net/problem/1167 트리의 지름
https://www.acmicpc.net/problem/1967 트리의 지름

A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.
For example, these are arithmetic sequence:
1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9

The sequence [1, 1, 2, 5, 7] is not arithmetic.

A zero-indexed array A consisting of N numbers is given.
A slice of that array is any pair of integers(P, Q) suth that 0 <= P < Q < N.
A slice (P, Q) of array A is called arithmetic if the sequence.
A[P], A[P+1], ..., A[Q-1], A[Q]
is arthmetic. In particular, this means that P + 1 < Q.
Write a function:
class Solution { public int solution(int[] A); }

that, given array A consisting of N numbers, returns the number of arithmetic slices in A.

For example, given array A suth that:
A[0] = -1
A[1] = 1
A[2] = 3
A[3] = 3
A[4] = 3
A[5] = 2
A[6] = 1
A[7] = 0

the function should return 5 because there are fice arithmetic slices of that array, namely
(0, 2), (2, 4), (4, 6), (4, 7), (5, 7)

################################################################################

In this problem we consider binary trees, represented by pointer data structures.
A binary tree is either an empty tree or a node(called the root)
consisting of a single integer value and two further binary trees, called the left subtree and the right subtree.
For example, the figure below shows a binary tree consisting of six nodes.
Its root contains the value 5, and the roots of its left and right subtrees have the values 3 and 10, respectively.
The right subtree of the node containing the value 10, as well as the left and right subtrees of the nodes containing the values 1, 20 and 21, are empty trees.
5
3,      10
21, 21, 1
A binary tree can be given using a pointer data structure.
Assume that the following declarations are given:

class Tree {
    public int x;
    public Tree l;
    public Tree r;
}

An empty tree is represented by an empty pointer(denoted by null).
A non-empty tree is represented by a pointer to an object representing its root.
The attribute x holds the integer containte in the root, whereas attributes l and r hold the left and right subtrees of the binary tree, respectively

A path in a binary tree is a non-empty sequence of nodes that one can traverse by following the pointers.
The length of a path is the number of pointers it traverses.
More formally, a path of length K is a sequence of node P[0], P[1], ...,P[K], such that node P[l + 1] is the root of the left or right subtree of P[l], for 0 <= l < k.
For example, the sequence of nodes with values 5, 3, 21 is a path of length 2 in the tree from the above figure.
The sequence of nodes with values 10, 1, is a path of length 1.
The sequence of nodes with values 20, 2, 21 is not a valid path.
The height of a binary tree is defined as the length of the longest possible path in the tree.
In particular, a tree consisting of only one node has height 0 and, conventionally, an empty tree has height -1.
For example, the tree shown in the above figure is of height 2.

A binary tree T is given.
A node of tree T containing value V is described as visible if the path from the root of the tree to that node does not contain a node with any value exceding V.
In particular, the root is always visible and nodes with values lower than that of the root are never visible.

For example, the tree shown in the above figure has four visible nodes:
namely, those with values, 5, 10, 20 and 21. 
The node with value 1 is not visible because there is a node with value 10 on the path from the root to that node.
The node with value 3 is not visible because its value is lower than that of the root, which has value 5.

Write function:
class Solution { public int solution(Tree T); }

that, given a binary tree T consisting of N nodes, returns its number of visible nodes, 
For example, given the tree shown in the figure above, the function should return 4, as explained above.

Given tree T with the following structure:
8
2, 6
8, 7
the function should return 2, because the only visible nodes are those with value 8.

For the purpose of entering your own test cases, you can denote a tree recursively in the following way.
An empty binary tree is denoted by None.
A non-empty tree is denoted as (X, L, R), where X is the value contained in the root and L and R denote the left and right subtrees, respectively.
The trees from the above two figures can be denoted as:
(5, (3, (20, None, None), (21, None, None)), (10, (1, None, None), None))
and :
(8, (2, (8, None, None), (7, None, None)), (6, None, None))

################################################################################

People are waiting for an elevator in a hotel.
The elevator has limited capacity and you would like to analyse its movement.
The hotel has floors numbered from 0(ground floor) to M.
The elevator has a maximum capacity of X people and a weight limit of Y.
There are N people gathered at the ground floor, standing in a queue for the elevator.
You are given every person's weight A[K] and target floor B[K]. (That is, A[0] and B[0] represent the first person in the queue.)

People continue to enter the elevator, in the order of their position in.
the queue(and push the buttons for their target floors), for as long as there is room for them. 
(The queue order cannot be changed even if thereis room in the elevator for a particular person from the middle of the queue.)
Then elevator goes up and stops at every selected floor, and finally returns to the ground floor.
This process is repeated until there are no more people in the queue.
The goal is to count the total number of times that the elevator stops.

For example, consider a hotel with floors numbered from 0 to M = 5, with an elevator with a maximum capacity of X = 2 people and a weight limit of Y = 200.
the weights A and target floors B are:
A[0] = 60    B[0] = 2
A[1] = 80    B[1] = 3
A[2] = 40    B[2] = 5

The elevator will take the first two passengers together, stop at the 2nd and 3rd floors, then return to the ground floor.
Then, it will take the last passenger, stop at the 5th floor and return to the ground floor.
In total, the elevator will stop five times.
Note that this number includes the last stop at the ground floor.

Write a function:
class Solution { public int solution(int[] A, int[] B, int M, int X, int Y); }
that, given zero-indexed arrays A and B consisting of N integers, and numbers X, Y and M as described above, returns the total number of times the elevator stops.

For example, given the above data, the function should return 5, as explained above.

For example, given M = 3, X = 5, Y = 200 and the following arrays:
A[0] = 40    B[0] = 3
A[1] = 40    B[1] = 3 
A[2] = 100   B[2] = 2
A[3] = 80    B[3] = 2
A[4] = 20    B[4] = 3

the function should return 6, as the elevator will move in two stages:
with the first three people and then with the two remaining people.

 